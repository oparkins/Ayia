#!/usr/bin/env node
/**
 *  Fetch a version and convert all data to JSON format.
 *
 */
const Bible   = require('..');
const Cheerio = require('cheerio');
const sprintf = require('sprintf-js').sprintf;

async function main() {
  const args  = process.argv.slice(1);
  const vers  = args[1];
  let   ref_filter;
  if (vers == null) { _usage( args ) }

  if (args.length > 2) {
    const [ only_bk, only_ch, only_vs ]  = args[2].split(/[ :\.]+/);

    const book = Bible.getBook( only_bk );
    if (book) {
      ref_filter = book.abbr;

      if (only_ch) {
        ref_filter += `.${only_ch}`;
        if (only_vs)  { ref_filter += `.${only_vs}` }
      }
    }
  }
  // /*
  console.log('>>> Version: %s %s', vers, (ref_filter || ''));
  // */

  Bible.getVersion( vers )
    .then( version => {
      json = { ...version, books:{} };

      Object.entries(version.books).forEach( ([key,val]) => {
        const bookJson  = _parseBook( key, val, ref_filter );

        if (bookJson) { json.books[key] = bookJson }
      });

      console.log( JSON.stringify( json, null, 2 ) );
    })
    .catch(err => {
      console.error('***', err);
    });
}

main();

/****************************************************************************
 * Private helpers {
 *
 */

/**
 *  Present usage information and exit.
 *  @method _usage
 *  @param  args    The incoming arguments {Array};
 *
 *  @return void  (exits the process)
 *  @private
 */
function _usage( args ) {
  const Path  = require('path');
  const prog  = Path.basename( args[0] );
  console.log(`
***
*** Usage: ${prog} version-abbreviation [book[.chapter[.verse]]]
***
`);

  process.exit(-1);
}

/**
 *  Parse a single book.
 *  @method _parseBook
 *  @param  abbrev        The book abbreviation {String};
 *  @param  chapters      The chapter data for this book {Object};
 *  @param  [ref_filter]  If provided, only present books, chapters, and verses
 *                        that match the filter ( BOK[.CHAPTER[.VERSE]] )
 *                        {String};
 *
 *  @return A simple object representing the given book {Object | undefined};
 *  @private
 */
function _parseBook( abbrev, chapters, ref_filter = null ) {
  const [ only_book, only_ch, only_vs ] = (typeof(ref_filter) === 'string'
                                            ? ref_filter.split('.')
                                            : []);
  if (only_book && only_book !== abbrev) { return }

  /*
  console.log('_parseBook( %s ): ref_filter[ %s ] => '
              +   'only_book[ %s ], only_ch[ %s ], only_vs[ %s ] => %s',
              abbrev, ref_filter, only_book, only_ch, only_vs);
  // */

  const bkJson  = {};
  Object.entries( chapters ).forEach( ([chp, lines]) => {
    if (only_ch && only_ch != chp) { return }

    const $         = Cheerio.load( lines.join( '' ) );
    const children  = $( '.chapter' ).children();

    /* Determine the number of verses by counting the unique .verse[data-usfm]
     * values {
     */
    const verseIds  = new Set();

    children.find('.verse[data-usfm]').each( (idex,el) => {
      const usfm  = _getAttr( el, 'data-usfm' );
      if (usfm) { verseIds.add( usfm ) }
    });
    const verses  = verseIds.size;
    // verse count }

    const chJson    = {
      verse_count : verseIds.size,
      content     : [],
    };

    children.each( (idex, el) => {
      const classes = _getClasses( el );
      const cls0    = (classes.length > 0 && classes[0]);

      /* :XXX: If we are NOT filtering by verse, do not pass the reference
       *       filter to _parseEl() since it does NOT have verse information
       *       that would match the `data-usfm` attribute.
       */
      const vsJson  = _parseEl( $, idex, el, cls0,
                                (only_vs ? ref_filter : null) );

      chJson.content.push( vsJson );
    });

    bkJson[ chp ] = chJson;
  });

  return bkJson;
}

/**
 *  Parse a single line of chapter HTML.
 *  @method _parseEl
 *  @param  $               The top-level Cheerio instance {Cheerio};
 *  @param  idex            The index of the HTML line within the parent
 *                          {Number};
 *  @param  el              The target HTML element {Object};
 *  @param  cls0            The first element of the 'class' attribute for
 *                          `$el` {String};
 *  @param  [ref_filter]    If provided, only show verses with a matching
 *                          'data-usfm' attribute {String};
 *  @param  [in_verse = false]
 *                          If provided, we have already matched `ref_filter`
 *                          and should process this element without further
 *                          regard to `ref_filter` {Boolean};
 *  @param  [indent = 4 ]   The number of characters to indent each output line
 *                          {NUmber};
 *
 *  @return A simple object representing the given element
 *          {Object | undefined};
 *  @private
 */
function _parseEl( $, idex, el, cls0,
                  ref_filter=null, in_verse=false, indent=4 ) {
  const $el       = $(el);
  const oPad      = ' '.padStart( indent,     ' ' );
  const label     = (cls0 || el.type);
  const children  = el.children || [];  //$el.children();
  let   do_output = (ref_filter == null || in_verse);
  let   json;

  if (children.length < 1) {
    // NO children
    if (do_output) {
      json = {
        [label]: $el.text(),
      };
    }
    return json;
  }

  const usfm  = _getAttr( el, 'data-usfm' );
  if (usfm) {
    /* This element has a 'data-usfm' attribute and so is related to a verse.
     *
     * If there is a `ref_filter` and the element has a 'verse' class, see if
     * the filter matches this verse and adjust `in_verse` and `do_output`
     * accordingly.
     */
    if (ref_filter && label === 'verse') {
      in_verse  = (ref_filter === usfm);
      do_output = in_verse;
    }

    if (do_output) {
      json = {
        verse_id: usfm,
        [label] : [],
      };
    }

  } else if (do_output) {
    json = {
      [label]: [],
    };
  }

  //console.log('%s: html:', label, $el.prop('outerHTML'));

  // Recursively parse all children
  children.forEach( (ch, jdex) => {
    const classes = _getClasses( ch );
    const cls0    = (classes.length > 0 && classes[0]);
    const chJson  = _parseEl( $, jdex, ch, cls0, ref_filter, in_verse,
                              indent+2 );
    if (chJson) {
      if (json) { json[label].push( chJson ) }
      else      { console.log('=== Squelch:', chJson) }
    }
  });

  return json;
}

/**
 *  Fetch the specified attribute from the given element.
 *  @method _getAttr
 *  @param  el    The target element {Cheerio};
 *  @param  attr  The target attribute {String};
 *
 *  @return The value of the attribute {String | undefined};
 *  @private
 */
function _getAttr( el, attr ) {
  if (el.attribs == null) { return }

  return el.attribs[ attr ];
}

/**
 *  Fetch an array of CSS classes for the given element.
 *  @method _getClasses
 *  @param  el  The target element {Cheerio};
 *
 *  @return The array of CSS classes {Array};
 *  @private
 */
function _getClasses( el ) {
  const attrCls = _getAttr( el, 'class' ) || '';
  const classes = attrCls.split(/\s+/);

  return classes;
}

/* Private helpers }
 ****************************************************************************/

// vi: ft=javascript
