#!/usr/bin/env node
/**
 *  Fetch a version and convert all data to JSON format.
 *
 */
const Bible   = require('..');
const Cheerio = require('cheerio');
const sprintf = require('sprintf-js').sprintf;

async function main() {
  const args  = process.argv.slice(1);
  const vers  = args[1];
  let   ref_filter;
  if (vers == null) { _usage( args ) }

  if (args.length > 2) {
    const [ only_bk, only_ch, only_vs ]  = args[2].split(/[ :\.]+/);

    const book = Bible.getBook( only_bk );
    if (book) {
      ref_filter = book.abbr;

      if (only_ch) {
        ref_filter += `.${only_ch}`;
        if (only_vs)  { ref_filter += `.${only_vs}` }
      }
    }
  }
  // /*
  console.log('>>> Version: %s %s', vers, (ref_filter || ''));
  // */

  Bible.getVersion( vers )
    .then( version => {
      json = { ...version, books:{} };

      Object.entries(version.books).forEach( ([key,val]) => {
        const bookJson  = _parseBook( key, val, ref_filter );

        if (bookJson) { json.books[key] = bookJson }
      });

      console.log( JSON.stringify( json, null, 2 ) );
    })
    .catch(err => {
      console.error('***', err);
    });
}

main();

/****************************************************************************
 * Private helpers {
 *
 */

/**
 *  Present usage information and exit.
 *  @method _usage
 *  @param  args    The incoming arguments {Array};
 *
 *  @return void  (exits the process)
 *  @private
 */
function _usage( args ) {
  const Path  = require('path');
  const prog  = Path.basename( args[0] );
  console.log(`
***
*** Usage: ${prog} version-abbreviation [book[.chapter[.verse]]]
***
`);

  process.exit(-1);
}

/**
 *  Parse a single book.
 *  @method _parseBook
 *  @param  abbrev        The book abbreviation {String};
 *  @param  chapters      The chapter data for this book {Object};
 *  @param  [ref_filter]  If provided, only present books, chapters, and verses
 *                        that match the filter ( BOK[.CHAPTER[.VERSE]] )
 *                        {String};
 *
 *  @return A simple object representing the given book {Object | undefined};
 *  @private
 */
function _parseBook( abbrev, chapters, ref_filter = null ) {
  const [ only_book, only_ch, only_vs ] = (typeof(ref_filter) === 'string'
                                            ? ref_filter.split('.')
                                            : []);
  if (only_book && only_book !== abbrev) { return }

  let filter  = null;
  if (only_book) {
    filter = only_book;

    if (only_ch) {
      filter += `.${only_ch}`;
      if (only_vs)  { filter += `.${only_vs}([+]|$)` }
      else          { filter += '.[0-9]' }
    }

    filter = new RegExp( filter.replaceAll('.', '\\.'), 'i' );

    /*
    console.log('_parseBook(): ref_filter[ %s ] => [ %s / %s / %s ]',
                  ref_filter, only_book, only_ch, only_vs);
    console.log('_parseBook(): filter: %s', filter);
    // */
  }

  /*
  console.log('_parseBook( %s ): ref_filter[ %s ] => '
              +   'only_book[ %s ], only_ch[ %s ], only_vs[ %s ] => %s',
              abbrev, ref_filter, only_book, only_ch, only_vs);
  // */

  const bkJson  = {
    metadata: [],
    chapters: {},
  };
  Object.entries( chapters ).forEach( ([chp, lines]) => {
    if (only_ch && only_ch != chp) { return }

    const $         = Cheerio.load( lines.join( '' ) );
    const children  = $( '.chapter' ).children();

    // Locate all elements that comprise verses : .verse[data-usfm]
    const verses  = new Map();

    children.find('.verse[data-usfm]').each( (idex,el) => {
      const usfm  = _getAttr( el, 'data-usfm' );
      // assert( usfm != null )
      if (filter && !filter.test( usfm )) { return }

      let   verse = (verses.get( usfm ) || []);
      const json  = _parseEl( $, el );
      const key   = Object.keys( json ).shift();
      const val   = json[key];

      if (Array.isArray(val)) {
        verse = verse.concat( val );

      } else {
        verse.push( json[key] );
      }

      verses.set( usfm, verse );
    });

    const chJson    = {
      verse_count : verses.size,
      metadata    : [],
      verses      : {},
    };

    verses.forEach( (verse, id) => {
      const [ bk, ch, vs ] = id.split('.');

      chJson.verses[ vs ] = verse;
    });

    bkJson.chapters[ chp ] = chJson;
  });

  return bkJson;
}

/**
 *  Parse a single line of chapter HTML.
 *  @method _parseEl
 *  @param  $               The top-level Cheerio instance {Cheerio};
 *  @param  el              The target HTML element {Object};
 *
 *  @return A simple object representing the given element
 *          {Object | undefined};
 *  @private
 */
function _parseEl( $, el ) {
  const classes   = _getClasses( el );
  const cls0      = (classes.length > 0 && classes.shift());
  const $el       = $(el);
  const label     = (cls0 || el.type)
                  + (classes.length > 0
                        ? '.' + classes.join('.')
                        : '');
  const children  = el.children || [];  //$el.children();
  let   json;

  if (label === 'content') {
    return $el.text();
  }

  if (children.length < 1) {
    // NO children
    if (label === 'text') {
      json = $el.text();

    } else {
      json = {
        [label]: $el.text(),
      };
    }
    return json;
  }

  // Recursively parse all children
  let ar  = [];
  children.forEach( (ch, jdex) => {
    const chJson  = _parseEl( $, ch );
    if (chJson) {
      if (chJson.body) {
        if (Array.isArray(chJson.body)) {
          ar = ar.concat( chJson.body );
        } else {
          ar.push( chJson.body );
        }

      } else {
        ar.push( chJson );
      }
    }
  });

  if (ar.length === 1) {
    // Replace this single-item array with just the item.
    ar = ar.pop();
  }

  return {
    [label]: ar,
  };
}

/**
 *  Fetch the specified attribute from the given element.
 *  @method _getAttr
 *  @param  el    The target element {Cheerio};
 *  @param  attr  The target attribute {String};
 *
 *  @return The value of the attribute {String | undefined};
 *  @private
 */
function _getAttr( el, attr ) {
  if (el.attribs == null) { return }

  return el.attribs[ attr ];
}

/**
 *  Fetch an array of CSS classes for the given element.
 *  @method _getClasses
 *  @param  el  The target element {Cheerio};
 *
 *  @return The array of CSS classes {Array};
 *  @private
 */
function _getClasses( el ) {
  const attrCls = _getAttr( el, 'class' ) || '';
  const classes = attrCls.split(/\s+/).filter( str => str.length > 0 );

  return classes;
}

/* Private helpers }
 ****************************************************************************/

// vi: ft=javascript
