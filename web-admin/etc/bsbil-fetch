#!/usr/bin/env node
const Path  = require('path');
const http = require('https');
const fs = require('fs');
const execSync = require('child_process').execSync;
const readline = require('readline');

// Constants used later
const TABLES_URL = "https://bereanbible.com/bsb_tables.xlsx"
const TABLES_FILE = "bsb_tables.xlsx"
const PATH_CACHE  = Path.resolve( Path.join( __dirname, '..', 'cache' ) );
const PATH_XLSX   = Path.join( PATH_CACHE, TABLES_FILE );
const PATH_CSV    = Path.join( PATH_CACHE,
                                Path.basename(TABLES_FILE, '.xlsx')+'.csv' );
const PATH_JSON   = Path.join( PATH_CACHE,
                                Path.basename(TABLES_FILE, '.xlsx')+'.json' );

main()
  .catch(err => {
    console.error('*** main error:', err);
  });

/****************************************************************************
 * Async main
 */
async function main() {
  const existsXlsx  = fs.existsSync( PATH_XLSX );
  const existsCsv   = fs.existsSync( PATH_CSV );
  //const existsJson  = fs.existsSync( PATH_JSON );

  if (! existsXlsx) {
    // Download the translation table document
    console.log('>>> Download source %s ...', TABLES_URL);
    await fetch_url( TABLES_URL, PATH_XLSX );

  } else if ( existsXlsx ) {
    console.log('=== Using cached XLSX translation tables');
  }

  if (! existsCsv ) {
    // Check for dependencies like libreoffice
    try {
      execSync('soffice --version',
        function (error, stdout, stderr) { 
          if (! error) {
            console.log('>>> soffice version: ' + stdout);
          }
        }
      );

    } catch {
        console.error('*** Please install LibreOffice');
        return;
    }

    // Use libreoffice to convert XLSX to CSV
    console.log('>>> Converting translation tables to CSV via libre-office ...');
    await xlsx_to_csv( PATH_XLSX, PATH_CSV );

  } else {
    console.log('=== Using cached CSV translation tables');
  }

  await csv_to_json( PATH_CSV, PATH_JSON );
}

/**
 *  Fetch the given URL and write it to the provied ouptut path.
 *
 *  @method fetch_url
 *  @param  url       The target url {String};
 *  @param  out_path  The path to the output content {String};
 *
 *  @return A promise for results {Promise};
 *          - on success, true {Boolean};
 *          - on failure, an error {Error};
 */
function fetch_url( url, out_path ) {
  return new Promise( (resolve, reject) => {
    const file    = fs.createWriteStream( out_path );
    const request = http.get(url, (response) => {
      let err;

      response.pipe(file);

      file.on('error', (er) => { err = er });

      // after download completed close filestream
      file.on('finish', () => {
        file.close();

        if (err) {
          console.error('*** Download error:', err);
          return reject( err );

        } else {
          console.log('>>> Download Completed');
          return resolve( true );
        }
      });
    });
  });
}

/**
 *  Use soffice/libre-office to convert an XLSX file to CSV
 *
 *  @method xlsx_to_csv
 *  @param  path_xlsx   The path to the (input) XLSX file {String};
 *  @param  path_csv    The path to the (output) CSV file {String};
 *
 *  @return A promise for results {Promise};
 *          - on success, true {Boolean};
 *          - on failure, and error {Error};
 */
function xlsx_to_csv( path_xlsx, path_csv ) {
  return new Promise( (resolve, reject) => {
    /* Params located at:
     *  https://help.libreoffice.org/latest/en-US/text/shared/guide/csv_params.html
     */
    const cmdline = [
      'soffice',
      '--convert-to',
      'csv:"Text - txt - csv (StarCalc)":44,34,UTF8,0,,0,true,false,false,false,false,5',
      path_xlsx,
    ];
    try {
      execSync( cmdline.join(' '),
        { cwd: process.cwd() },
        function (error, stdout, stderr) {
          console.log('stdout: ' + stdout);
          console.log('stderr: ' + stderr);
          if (error !== null) {
            console.log('exec error: ' + error);
            return reject( error );
          }

          return resolve( true );
      });

    } catch(err) {
      return reject( err );
    }
  });
}

/**
 * Convert a CSV line ('asd',asdf,'a sdf',...) to an array, (['asd', 'asdf', 'a
 * sdf']). Useful to later zipping to the header line to make a dictionary.
 *
 * @method  csv_line_to_array
 * @param   line  The string that contains the CSV line {String};
 *
 * @return  An array of records {Array};
 */
function csv_line_to_array(line) {

  // Process character by character
  const res             = []
  let   value           = '';
  let   inside_a_value  = false;

  for (ch of line) {
    if (ch === '\"') {

      inside_a_value = !inside_a_value;

      // We are at the end of an entry, let's push it on our array
      //if ( value !== "" ) {
      //  res.push( value )
      //  value = ""
      //}

    } else if ( ch === ',' ) { 

      if ( !inside_a_value ) {
        res.push( value )
        value = ""

      } else {
        // Since value has values, the comma is part of the actual text.
        value += ch;
      }

    } else {
      //Nothing special, just add the character to our temp value
      value += ch;
    }
  }

  res.push( value )

  return res
}

/**
 *  Convert a CSV file to JSON
 *
 *  @method csv_to_json
 *  @param  path_csv    The path to the (input) CSV file {String};
 *  @param  path_json   The path to the (output) JSON file {String};
 *
 *  @return A promise for results {Promise};
 *          - on success, true {Boolean};
 *          - on failure, an error {Error};
 */
function csv_to_json( path_csv, path_json ) {
  const keys  = [
    'sort_heb', 'sort_grk', 'sort_bsb', 'language', 'vs', 'wlc', '<=>',
    'translit', 'parsing', 'type_of_speech', 'strongs', 'verse',
    'heading', 'xref', 'vers_bsb', 'footnotes', 'bdb',
  ];

  console.log('>>> Convert CSV to JSON ...');
  return new Promise((resolve, reject) => {
    const inputStream       = fs.createReadStream(  path_csv );
    const outputFilestream  = fs.createWriteStream( path_json );
    const rl                = readline.createInterface({
      input: inputStream,
      crlfDelay: Infinity
    });

    const amount_of_lines_to_ignore = 1;
    let   nlines        = 0;
    let   header        = [];
    let   first_object  = true;

    // Start our array of verses...
    outputFilestream.write("[")

    rl.on('line', (line) => {
      nlines++;

      if (nlines <= amount_of_lines_to_ignore) {
        return;
      }

      if (header.length === 0) {
        header = csv_line_to_array( line );

      } else {
        const line_array  = csv_line_to_array( line );
        const jsonObj     = {};
        
        for (let idex in header) {
          const key = keys[ idex ] || header[ idex ];

          jsonObj[ key ] = line_array[ idex ];
        }

        if (!first_object) {
          outputFilestream.write(',\n');

        } else {
          first_object = false
          outputFilestream.write('\n');
        }

        outputFilestream.write( '  ' );
        outputFilestream.write( JSON.stringify(jsonObj) );
      }
    });

    rl.on('error', (err) => {
      rl.close();
      return reject( err );
    });

    rl.on('close', () => {
      console.log('>>> Finished parsing the %s lines of csv',
                    nlines.toLocaleString());
      console.log('>>>   Output: %s', path_json);
      outputFilestream.write("]")

      return resolve( true );
    });
  });
}
